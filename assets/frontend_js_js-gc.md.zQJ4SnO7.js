import{_ as a,c as e,o as r,V as t}from"./chunks/framework.SV1ROkXV.js";const m=JSON.parse('{"title":"JS垃圾回收机制","description":"","frontmatter":{},"headers":[],"relativePath":"frontend/js/js-gc.md","filePath":"frontend/js/js-gc.md","lastUpdated":1709440279000}'),l={name:"frontend/js/js-gc.md"},o=t('<h1 id="js垃圾回收机制" tabindex="-1">JS垃圾回收机制 <a class="header-anchor" href="#js垃圾回收机制" aria-label="Permalink to &quot;JS垃圾回收机制&quot;">​</a></h1><p>浏览器：</p><h2 id="引用计数法" tabindex="-1">引用计数法 <a class="header-anchor" href="#引用计数法" aria-label="Permalink to &quot;引用计数法&quot;">​</a></h2><p>引用计数法：对象被引用一次引用次数就 +1，引用次数为0 后，垃圾回收运行时清理掉次数为0 的</p><ul><li>优点：引用计数只需要在计数为0 时就可以回收，不需要遍历所有对象</li><li>缺点：计数器需要占很大的空间，无法解决循环引用无法回收的问题</li></ul><h2 id="标记清除法" tabindex="-1">标记清除法 <a class="header-anchor" href="#标记清除法" aria-label="Permalink to &quot;标记清除法&quot;">​</a></h2><p>标记清除法：定期将活动对象和不活动的对象进行分别标记，然后开始清除工作，最后还原标记，等待 下一轮清除工作</p><ul><li>优点：算法简单，</li><li>缺点：（内存碎片化，分配速度慢）清除后剩余的对象内存位置不变，导致空闲内存空间不连续，出现了内存碎片</li></ul><p>标记整理算法在标记结束后，将活动对象往内存一边移动</p><h2 id="分代式回收" tabindex="-1">分代式回收 <a class="header-anchor" href="#分代式回收" aria-label="Permalink to &quot;分代式回收&quot;">​</a></h2><p>V8回收机制优化：</p><p>分代式垃圾回收</p><ol><li>新生代回收：Scavenge算法、Cheney算法，Cheney算法将新生代内存一分为二，使用区和空闲区， 对活动区的对象进行标记，清理，活动区和空闲区身份互换，交换两次后，将活动区还在的老对象 放到老生代，如果交换后空闲区超过25%，将会把对象都放到老生代</li><li>老生代：存放一些空间大、存活时间长，如果放在新生代频繁复制交换，会非常耗时；老生代使用 标记清除法，进行清除，排序整理，标记整理 并行回收，读写锁 全停顿，增量标记、三色标记、写屏障 惰性清理</li></ol><h3 id="新生代" tabindex="-1">新生代 <a class="header-anchor" href="#新生代" aria-label="Permalink to &quot;新生代&quot;">​</a></h3><h3 id="老生代" tabindex="-1">老生代 <a class="header-anchor" href="#老生代" aria-label="Permalink to &quot;老生代&quot;">​</a></h3><h2 id="并行回收" tabindex="-1">并行回收 <a class="header-anchor" href="#并行回收" aria-label="Permalink to &quot;并行回收&quot;">​</a></h2><h2 id="增量标记" tabindex="-1">增量标记 <a class="header-anchor" href="#增量标记" aria-label="Permalink to &quot;增量标记&quot;">​</a></h2><h3 id="三色标记法" tabindex="-1">三色标记法 <a class="header-anchor" href="#三色标记法" aria-label="Permalink to &quot;三色标记法&quot;">​</a></h3><h3 id="写屏障" tabindex="-1">写屏障 <a class="header-anchor" href="#写屏障" aria-label="Permalink to &quot;写屏障&quot;">​</a></h3><h2 id="惰性清理" tabindex="-1">惰性清理 <a class="header-anchor" href="#惰性清理" aria-label="Permalink to &quot;惰性清理&quot;">​</a></h2><h2 id="并发回收" tabindex="-1">并发回收 <a class="header-anchor" href="#并发回收" aria-label="Permalink to &quot;并发回收&quot;">​</a></h2><h2 id="参考文档" tabindex="-1">参考文档 <a class="header-anchor" href="#参考文档" aria-label="Permalink to &quot;参考文档&quot;">​</a></h2><ul><li><a href="https://juejin.cn/post/6981588276356317214" target="_blank" rel="noreferrer">https://juejin.cn/post/6981588276356317214</a></li><li><a href="https://v8.js.cn/blog/concurrent-marking/" target="_blank" rel="noreferrer">https://v8.js.cn/blog/concurrent-marking/</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Memory_management" target="_blank" rel="noreferrer">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Memory_management</a></li><li><a href="https://www.youtube.com/watch?v=easvMCCBFkQ" target="_blank" rel="noreferrer">https://www.youtube.com/watch?v=easvMCCBFkQ</a></li></ul>',23),i=[o];function n(h,s,c,d,u,p){return r(),e("div",null,i)}const _=a(l,[["render",n]]);export{m as __pageData,_ as default};
