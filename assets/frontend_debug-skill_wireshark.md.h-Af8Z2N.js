import{_ as p,c as l,J as s,V as o,o as c,G as a}from"./chunks/framework.SV1ROkXV.js";const F=JSON.parse('{"title":"wireshark网络抓包工具使用教程","description":"使用wireshark网络抓包工具分析网络数据包、协议、通信","frontmatter":{"title":"wireshark网络抓包工具使用教程","description":"使用wireshark网络抓包工具分析网络数据包、协议、通信","keywords":"wireshark,wireshark抓包工具,网络抓包工具,协议抓包,frontend debugger,chrome调试,调试技能,线上调试","logo":"https://ihengshuai-demo1.oss-cn-beijing.aliyuncs.com/icon-debug.png"},"headers":[],"relativePath":"frontend/debug-skill/wireshark.md","filePath":"frontend/debug-skill/wireshark.md","lastUpdated":1709440279000}'),t={name:"frontend/debug-skill/wireshark.md"},i=o(`<h1 id="wireshark网络抓包" tabindex="-1">wireshark网络抓包 <a class="header-anchor" href="#wireshark网络抓包" aria-label="Permalink to &quot;wireshark网络抓包&quot;">​</a></h1><p>到这里已经讲了两个抓包工具的使用了，大家应该对抓包不是很陌生了。而<a href="https://www.wireshark.org" target="_blank" rel="noreferrer">wireshark</a>相对于<a href="/frontend/debug-skill/fiddler.html">fiddler</a>和<a href="/frontend/debug-skill/charles.html">charles</a>更加偏向于网络层面的抓包或者说是一个网络封包分析工具。使用对象更适合于网络相关人员(网络管理员/相关运维等等)，目的用来截取网络通信，显示详细的封包资料。</p><p>wireshark可以用来检测网络环境、入侵侦测系统等网络层面的用处，相对于开发人员，可以用来分析一些基础的网络层面的基础，如HTTP协议、UDP协议、TCP/IP协议、ARP协议等对我们比较友好的网络协议，当然如果你熟练操作网络可以没有任何限制。</p><h2 id="下载安装" tabindex="-1">下载安装 <a class="header-anchor" href="#下载安装" aria-label="Permalink to &quot;下载安装&quot;">​</a></h2><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>由于一些历史原因，wireshark已经是个免费软件，下载简单，功能强大，非常适合网络协议的学习和认识</p></div><p><a href="https://www.wireshark.org" target="_blank" rel="noreferrer">wireshark</a>支持windows、macOS、Linux几个版本，基本上常见的操作系统都可以支持的，直接打开官网<a href="https://www.wireshark.org/#download" target="_blank" rel="noreferrer">下载页面</a>，选择适合自己的操作系统，下载即可，下载完后一路点击确定安装就可。这里作者是macOS，就安装了mac版，如无特殊备注，以下都以mac版本为基础介绍，其他大同小异。</p><p>下载后打开大概长这个样子，它可以捕获机器上所有物理网卡虚拟网卡的流量，选择一个网卡开始捕获</p><p><img src="https://ihengshuai-demo1.oss-cn-beijing.aliyuncs.com/005HV6Avgy1h7e4163efwj31k413cths.jpg" alt="iShot_2022-10-22_15.44.16.png"></p><h2 id="菜单栏" tabindex="-1">菜单栏 <a class="header-anchor" href="#菜单栏" aria-label="Permalink to &quot;菜单栏&quot;">​</a></h2><p><img src="https://ihengshuai-demo1.oss-cn-beijing.aliyuncs.com/005HV6Avgy1h7cm8lmc0jj315o02agnc.jpg" alt="iShot_2022-10-21_08.43.06.png"></p><p>菜单栏这里只讲下统计，它相对来说更加实用。统计内部有好多不同维度的分组，可以从不同维度去查看统计信息，如：流量、TCP流、UDP多播、HTTP等等。统计需要数据才可以统计出结果，可以先抓取少量的包，点击内部的流量图可以很清晰的看到网络通信</p><p><img src="https://ihengshuai-demo1.oss-cn-beijing.aliyuncs.com/005HV6Avgy1h7cm6x7c2fj31wc15gb29.jpg" alt="iShot_2022-10-21_08.41.25.png"></p><h2 id="工具栏" tabindex="-1">工具栏 <a class="header-anchor" href="#工具栏" aria-label="Permalink to &quot;工具栏&quot;">​</a></h2><p>当进来时会进入欢迎页面，可以选择指定的网络接口(本地、wifi)或直接点击左上角的鲨鱼图标开始抓包。</p><p><img src="https://ihengshuai-demo1.oss-cn-beijing.aliyuncs.com/005HV6Avgy1h7e46ruoeyj31k60nk1kx.jpg" alt="iShot_2022-10-22_15.49.40.png"></p><p>以上看到已经抓取了大量的网络数据包，下面开看看工具栏的作用</p><p><img src="https://ihengshuai-demo1.oss-cn-beijing.aliyuncs.com/005HV6Avgy1h7e3neadwzj31bu04mtal.jpg" alt="iShot_2022-10-22_15.09.52.png"></p><p>工具栏主要使用来控制抓包的，以上的图标按顺序依次是开始抓包、停止抓包、重新捕获、捕获选项(网卡、过滤器)、打开本地捕获文件、保存捕获文件、关闭捕获、重新加载捕获文件、搜索(过滤器)，基本上的图标控制按钮就这么简单，后面的都是对界面的一些控制，没什么说的，自己动手试试即可。</p><h2 id="过滤器" tabindex="-1">过滤器 <a class="header-anchor" href="#过滤器" aria-label="Permalink to &quot;过滤器&quot;">​</a></h2><p>当使用wireshark抓包时难免会有大量的抓包记录，而我们往往会针对某个网络包进行分析，而在这种大量数据下会严重影响到分析进度。为了避免其它数据造成的干扰，wireshark提供了过滤器来帮助过滤掉不必要的数据或只显示我们想要的数据。</p><p>过滤器分为<u><strong>捕获过滤器</strong></u>和<u><strong>显示过滤器</strong></u>，而捕获过滤器又可以对<u>网络接口</u>和<u>协议相关</u>的两个维度的过滤。显示过滤器主要是对抓取到的网络数据包进行过滤显示，其针对的显示方面的的过滤，而捕获过滤器则是从源头进行过滤。网络接口主要告诉wireshark要抓取哪个接口的网络数据包如：wifi、本地回环、以太网、虚拟网、蓝牙等等，协议方面的选项通常告诉其抓取什么协议、什么端口、ip等等，如：TCP协议、HTTP协议、广播、ip等等。</p><p>在进入wireshark时的欢迎页面就可以对进行不同的接口进行选择，双击接口就可以抓取了，不需要选择时，默认会抓取所有接口的数据，可以直接点击左上角的鲨鱼按钮开始抓取。</p><p><img src="https://ihengshuai-demo1.oss-cn-beijing.aliyuncs.com/005HV6Avgy1h7e4rn2cgqj31k413cdq0.jpg" alt="iShot_2022-10-22_16.09.43.png"></p><p>除了在欢迎页选择不同的网络接口外，也可以在抓包页面上方的类似设置的按钮中，也可以选择不同的接口和详细的抓包选项，如下图：</p><p><img src="https://ihengshuai-demo1.oss-cn-beijing.aliyuncs.com/005HV6Avgy1h7e5lo5e3vj31f00zak92.jpg" alt="iShot_2022-10-22_16.38.32.png"> 更详细过滤一些选项 <img src="https://ihengshuai-demo1.oss-cn-beijing.aliyuncs.com/005HV6Avgy1h7e56c27ssj31hu0wk4c0.jpg" alt="iShot_2022-10-22_16.02.54.png"></p><p>上面的过滤器我选择了<u>抓取本地接口和端口为9999</u>的数据包，这里我用<code>Nodejs</code>监听<code>9999</code>端口号开启了一个web服务，接着用curl请求这个地址：</p><div class="language-sh line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki material-theme-palenight vp-code"><code><span class="line"><span style="color:#FFCB6B;">➜</span><span style="color:#C3E88D;"> curl -I </span><span style="color:#F78C6C;">192.168</span><span style="color:#C3E88D;">.3.2:9999 # 请求成功</span></span>
<span class="line"><span style="color:#FFCB6B;">HTTP/1.1</span><span style="color:#F78C6C;"> 200</span><span style="color:#C3E88D;"> OK</span></span>
<span class="line"><span style="color:#FFCB6B;">X-Powered-By:</span><span style="color:#C3E88D;"> Express</span></span>
<span class="line"><span style="color:#FFCB6B;">Set-Cookie:</span><span style="color:#C3E88D;"> __ut=</span><span style="color:#F78C6C;">123456</span><span style="color:#89DDFF;">;</span><span style="color:#BABED8;"> Path</span><span style="color:#89DDFF;">=</span><span style="color:#C3E88D;">/</span></span>
<span class="line"><span style="color:#FFCB6B;">Content-Type:</span><span style="color:#C3E88D;"> application/json</span><span style="color:#89DDFF;">;</span><span style="color:#BABED8;"> charset</span><span style="color:#89DDFF;">=</span><span style="color:#C3E88D;">utf-8</span></span>
<span class="line"><span style="color:#FFCB6B;">Content-Length:</span><span style="color:#F78C6C;"> 79</span></span>
<span class="line"><span style="color:#FFCB6B;">ETag:</span><span style="color:#C3E88D;"> W/</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">4f-IdYGYravFqZ+6sBfe27/eQDuPDo</span><span style="color:#89DDFF;">&quot;</span></span>
<span class="line"><span style="color:#FFCB6B;">Date:</span><span style="color:#C3E88D;"> Sat, </span><span style="color:#F78C6C;">22</span><span style="color:#C3E88D;"> Oct </span><span style="color:#F78C6C;">2022</span><span style="color:#F78C6C;"> 08</span><span style="color:#C3E88D;">:46:19 GMT</span></span>
<span class="line"><span style="color:#FFCB6B;">Connection:</span><span style="color:#C3E88D;"> keep-alive</span></span>
<span class="line"><span style="color:#FFCB6B;">Keep-Alive:</span><span style="color:#C3E88D;"> timeout=</span><span style="color:#F78C6C;">5</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p><img src="https://ihengshuai-demo1.oss-cn-beijing.aliyuncs.com/005HV6Avgy1h7e5xien0lj31jq0kye3e.jpg" alt="iShot_2022-10-22_16.49.58.png"></p><p>现在看看当前的抓包情况，可以看到已经抓取到了，原地址和目标地址都是<code>192.168.3.2</code>本机局域网地址，还看到TCP协议、HTTP协议，如果现在只想分析HTTP协议的数据包呢，就可以用上显示过滤器了。设置它很简单，在记录上方的输入框即可过滤。如下图：显示<code>http</code>协议的请求。</p><p><img src="https://ihengshuai-demo1.oss-cn-beijing.aliyuncs.com/005HV6Avgy1h7e65qwx1fj31dq0awjxz.jpg" alt="iShot_2022-10-22_16.57.26.png"></p><p>以上还可以再细分，可以结合多个过滤选项使用<code>and</code>/<code>or</code>进行连接过滤，如http请求的携带了query</p><div class="language- line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight vp-code"><code><span class="line"><span>http and http and http.request.uri.query.parameter</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>这里过滤选项不需要记下来，点击输入框前面的小图标，可以列出不同的选项，点击后可以在输入框中添加<code>.</code>进行属性的进一步过滤。除了这个内置的显示过滤外，可以点击菜单栏的放大镜按钮，也会显示出过滤的输入框。这里相对来说有了更广的过滤条件，可以使用显示过滤、正则搜索、十六进制、字符串等等，点击搜索即可，搜索后并不会将不在范围的记录隐藏掉，而知识将目标高亮而已。</p><p><img src="https://ihengshuai-demo1.oss-cn-beijing.aliyuncs.com/005HV6Avgy1h7e6bdfsdzj31iy0a245k.jpg" alt="iShot_2022-10-22_17.03.18.png"></p><h2 id="arp协议" tabindex="-1">ARP协议 <a class="header-anchor" href="#arp协议" aria-label="Permalink to &quot;ARP协议&quot;">​</a></h2><p>通过前面的学习你应该对wireshark这款软件的抓包基本功能有了了解，现在就来使用它来抓取数据包分析吧，本文会分别介绍ARP协议、TCP协议等网络协议，让我们以ARP协议开始吧。</p><p>在抓包开始前首先要明白什么是<a href="https://baike.baidu.com/item/ARP" target="_blank" rel="noreferrer">ARP协议</a>，了解协议本身有助于我们抓取的准备和方向，这里简单的概述下。</p><p>ARP是地址解析协议，从协议层次角度是个网络层协议，功能角度是链路层协议，用来查询ip所对应的mac地址。在互联网通信中，主机与主机之间通信，都是通过OSI模型从上到下的协议将数据封装最终发送到目的主机，通常情况下我们常见的是对应主机的ip，然后就可以知道目标主机的位置了，但这只是表面上的，通信双方还需要知道双方的mac地址才能通信，没有mac地址就像快递只写了收件人姓名，却没有收件地址一样。</p><p>上层应用程序只关心ip地址而不关系mac地址，<u>mac地址需要通过ARP协议获取目标主机地址</u>，完成数据的封装。那么ARP协议是如何获取目标主机的mac地址的，假如这里有两台机器：p1的ip地址<code>192.168.3.1</code>，p2的ip地址<code>192.168.3.2</code>，当p1想和p2通信时，从OSI协议封装顺序发送方自顶向下封装数据，ARP从上层知道了p2的目标ip地址，然后封装ARP数据包，将自己的ip地址和mac地址和对方的ip和mac占位地址封装，然后通过以太网的<u><strong>广播</strong></u>形式发送出去，交换机、网关或路由器等设备接收到广播包后，会将数据发给同一局域网的其他主机，当不同的主机接受到广播包后，会判断自己是不是这个发送者寻找的ip，如果不是则会将包丢弃掉不做任何应答；而如果当前主机和目的ip一致的话，将会接受此包并将自己的mac地址封装进去，并以单播的形式回应发送主机方，发送主机方就会知道目标ip所对应的mac地址了；如果在局域网中没找到响应的主机，交换机等会继续向上发送数据包直到找到位置。</p><p><img src="https://ihengshuai-demo1.oss-cn-beijing.aliyuncs.com/005HV6Avgy1h7exa6rqjlj31qo0xcjvw.jpg" alt="iShot_2022-10-23_08.28.31.jpg"></p><p>上图简单的画了请求的过程：</p><ol><li>发送方ARP广播发送数据包请求到交换机</li><li>交换机转发给局域网内的主机</li><li>不是目标ip的主机丢弃掉数据包，目标ip主机接收数据包</li><li>目标主机以单播的形式回应发送方</li></ol><div class="tip custom-block"><p class="custom-block-title">小提示</p><p>在ARP请求广播过程中，途径的网关和其他接收到广播的主机虽然不是目标主机，但也会在自己的ARP缓存表中记住发送方的ip和mac地址，这是方便以后其他主机向目标主机通信。</p><p>当目标主机找到后，也会记住发送方的ip和mac地址，然后将自己的mac地址和ip地址封装数据后以单播的形式回应发送给发送方。</p></div><p>接下来就用wireshark抓包看看实际的网络请求情况，这里一台机器的ip为<code>192.168.3.8</code>，现在让它请求网关<code>192.168.3.1</code>，这里使用linux的<a href="https://www.kali.org/tools/amap" target="_blank" rel="noreferrer">nmap</a>扫描工具扫描网关。</p><p>首先先打开wireshark监听抓包，这里直接抓取所有的接口，在显示过滤器中输入<code>ARP</code>协议来过滤显示ARP协议的数据包。</p><div class="language-sh line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki material-theme-palenight vp-code"><code><span class="line"><span style="color:#FFCB6B;">nmap</span><span style="color:#F78C6C;"> 192.168</span><span style="color:#C3E88D;">.3.1 # 然后会找到以下信息</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;"># Starting Nmap 7.70 ( https://nmap.org ) at 2022-10-22 22:02 CST</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;"># Nmap scan report for 192.168.3.1</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;"># Host is up (0.0070s latency).</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;"># Not shown: 972 closed ports</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;"># PORT      STATE    SERVICE</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;"># 3/tcp     filtered compressnet</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;"># 53/tcp    open     domain</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;"># 80/tcp    open     http</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;"># ....</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FFCB6B;">arp</span><span style="color:#C3E88D;"> -a</span><span style="color:#676E95;font-style:italic;"> # 查看ARP缓存表信息</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;"># ➜ arp -a            </span></span>
<span class="line"><span style="color:#676E95;font-style:italic;"># _gateway (192.168.3.1) at dc:33:xx:xx:xx:07 [ether] on enp0s5  # 这里就是网关被找到了</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;"># ? (192.168.3.2) at 38:f9:xx:xx:05:db [ether] on enp0s5</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p>上面通过扫描工具扫描网关，再查看ARP缓存表中已经缓存了网关信息，接下来看看抓包情况：</p><p><img src="https://ihengshuai-demo1.oss-cn-beijing.aliyuncs.com/005HV6Avgy1h7exxpipkwj31k60c2agi.jpg" alt="iShot_2022-10-22_22.05.39.png"></p><p>ARP请求： <img src="https://ihengshuai-demo1.oss-cn-beijing.aliyuncs.com/005HV6Avgy1h7exyt2n3ej31js0i07dz.jpg" alt="iShot_2022-10-22_22.09.38.png"></p><p>ARP应答： <img src="https://ihengshuai-demo1.oss-cn-beijing.aliyuncs.com/005HV6Avgy1h7exz8j210j31k00jq13r.jpg" alt="iShot_2022-10-22_22.13.09.png"></p><p>从抓包数据可以看到，首先<code>Apple</code>(192.168.3.8)主机以广播的形式发送数据包，ARP请求数据包中有自己的Send MAC address、ip address还有目标主机的ip<code>192.168.3.1</code>和mac地址<code>00:00:00:00:00:00</code>(这里0表示坑位待目标填写)，携带信息<code>Who has 192.168.3.1? tell 192.168.3.8</code>。当<code>Huawei</code>(网关192.168.3.1)接受到<code>Apple</code>发送来的数据包后，将自己的mac地址封装仅需其他的保持不变，再以单播的形式发送ARP Reply数据包，携带信息<code>192.168.3.1 at xx:xx:xx:xxx</code>，这样在<code>Apple</code>接收到数据包后就知道了目标的Mac地址了，就可以进行数据发送了。</p><p>这里简单说下ARP数据包中一些字段：</p><ul><li>Hardware type：硬件类型(标识链路层协议)</li><li>Protocol type：协议类型(标识网络层协议)</li><li>Hardware size：硬件地址大小(标识mac地址长度)，这里是6字节，48bit</li><li>Protocol size：协议地址大小(表示ip地址长度)，这里是4字节，32bit</li><li>Opcode：操作码(表示ARP请求类型)，1表示请求，2表示应答</li><li>Sender Mac address：发送者mac地址</li><li>Sender IP address：发送者ip地址</li><li>Target MAC address：目标mac地址</li><li>Target IP address：目标ip地址</li></ul><p>以上便是ARP协议的基本原理，通过<a href="https://www.kali.org/tools/amap" target="_blank" rel="noreferrer">nmap</a>扫描工具，再用wireshark进行抓包分析后应该已经对ARP协议不陌生了，基本就是<u>一问一答</u>简单形式。当然这里主要还是讲wireshark怎么抓取ARP数据包，来理解ARP的简单概念，至于ARP的更详细的概念可以看看其他文章，如果没有后面也会更新相关文章。</p><h2 id="tcp协议" tabindex="-1">TCP协议 <a class="header-anchor" href="#tcp协议" aria-label="Permalink to &quot;TCP协议&quot;">​</a></h2><p>TCP协议是基于字节流面向连接、可靠的、全双工的单播协议，在通信前必须建立连接，也就是常说的三次握手，然后会断开进行四次挥手。我们来先了解下TCP头部。 <img src="https://ihengshuai-demo1.oss-cn-beijing.aliyuncs.com/005HV6Avgy1h7f8ebxzb4j30g905u40a.jpg" alt="g0ywreqte9.png"></p><ul><li>源端口、目标端口：TCP里没有源IP和目的IP，这是IP层协议的事情，源IP、源端口、目标IP、目标端口构成了TCP<code>四元组</code>，一个四元组可以标识一个连接。</li><li>序列号：用于确认包的的顺序，序列号加上报文长度，用于确定传输的是哪一段数据。</li><li>确认号：TCP使用确认号来告知对方下一个期望接受的序列号</li><li>标志位：用来发起连接同步初始序列号，有些用来确认数据包，还有用来结束连接的 <ul><li>SYN：用于发起连接数据包同步初始序列号</li><li>ACK：确认数据，只有当ACK=1时有效</li><li>RST：强制断开连接</li><li>FIN：告知对方数据发送完毕，准备断开连接</li><li>PSH：告知对方数据包收到后马上交给应用层，不能缓存</li></ul></li><li>窗口大小：用来控制对方发送的数据量</li></ul><blockquote><p>更多TCP的详细内容请查看我的<a href="/frontend/computer-network/tcp-protocol.html">「TCP协议」</a>一文</p></blockquote><p>上面简单的介绍了TCP头部部分信息，TCP的连接由发送SYN开始，结束时通过FIN断开连接。下面我们就通过wireshark进行抓包分析。因为HTTP请求也是基于TCP协议的，这里以HTTP请求为例展开三次握手和四次挥手的细节。</p><p>这里开启一个node服务作为web服务器：</p><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight vp-code"><code><span class="line"><span style="color:#C792EA;">const</span><span style="color:#BABED8;"> express </span><span style="color:#89DDFF;">=</span><span style="color:#82AAFF;"> require</span><span style="color:#BABED8;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">express</span><span style="color:#89DDFF;">&quot;</span><span style="color:#BABED8;">)</span></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#BABED8;"> app </span><span style="color:#89DDFF;">=</span><span style="color:#82AAFF;"> express</span><span style="color:#BABED8;">()</span></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#BABED8;"> port </span><span style="color:#89DDFF;">=</span><span style="color:#BABED8;"> process</span><span style="color:#89DDFF;">.</span><span style="color:#BABED8;">env</span><span style="color:#89DDFF;">.</span><span style="color:#BABED8;">PORT </span><span style="color:#89DDFF;">||</span><span style="color:#F78C6C;"> 9999</span></span>
<span class="line"></span>
<span class="line"><span style="color:#BABED8;">app</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">use</span><span style="color:#BABED8;">(</span><span style="color:#C792EA;">async</span><span style="color:#89DDFF;"> (</span><span style="color:#BABED8;font-style:italic;">req</span><span style="color:#89DDFF;">,</span><span style="color:#BABED8;font-style:italic;"> res</span><span style="color:#89DDFF;">,</span><span style="color:#BABED8;font-style:italic;"> next</span><span style="color:#89DDFF;">)</span><span style="color:#C792EA;"> =&gt;</span><span style="color:#89DDFF;"> {</span></span>
<span class="line"><span style="color:#BABED8;">  res</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">setHeader</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">connection</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span><span style="color:#89DDFF;"> &quot;</span><span style="color:#C3E88D;">close</span><span style="color:#89DDFF;">&quot;</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#BABED8;">  res</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">json</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    url</span><span style="color:#89DDFF;">:</span><span style="color:#BABED8;"> req</span><span style="color:#89DDFF;">.</span><span style="color:#BABED8;">url</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#89DDFF;">    ...</span><span style="color:#BABED8;">req</span><span style="color:#89DDFF;">.</span><span style="color:#BABED8;">headers</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#89DDFF;">    ...</span><span style="color:#BABED8;">req</span><span style="color:#89DDFF;">.</span><span style="color:#BABED8;">query</span></span>
<span class="line"><span style="color:#89DDFF;">  }</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#89DDFF;">}</span><span style="color:#BABED8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#BABED8;">app</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">listen</span><span style="color:#BABED8;">(port</span><span style="color:#89DDFF;">,</span><span style="color:#89DDFF;"> ()</span><span style="color:#C792EA;"> =&gt;</span><span style="color:#89DDFF;"> {</span></span>
<span class="line"><span style="color:#BABED8;">  console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">\`</span><span style="color:#C3E88D;">Server is running on port </span><span style="color:#89DDFF;">\${</span><span style="color:#BABED8;">port</span><span style="color:#89DDFF;">}\`</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#89DDFF;">}</span><span style="color:#BABED8;">)</span><span style="color:#89DDFF;">;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><p>wireshark我们选择本地回环地址网卡接口，端口选择<code>9999</code><img src="https://ihengshuai-demo1.oss-cn-beijing.aliyuncs.com/005HV6Avgy1h7f9dh3pluj31fm0p6476.jpg" alt="iShot_2022-10-23_15.32.54.png"></p><h3 id="三次握手" tabindex="-1">三次握手 <a class="header-anchor" href="#三次握手" aria-label="Permalink to &quot;三次握手&quot;">​</a></h3><p>这里使用<code>curl</code>发起服务请求</p><div class="language-sh line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki material-theme-palenight vp-code"><code><span class="line"><span style="color:#FFCB6B;">➜</span><span style="color:#C3E88D;">  curl http://localhost:9999</span></span>
<span class="line"><span style="color:#89DDFF;">{</span><span style="color:#FFCB6B;">&quot;url&quot;</span><span style="color:#82AAFF;">:</span><span style="color:#FFCB6B;">&quot;/&quot;</span><span style="color:#FFCB6B;">,</span><span style="color:#FFCB6B;">&quot;host&quot;</span><span style="color:#82AAFF;">:</span><span style="color:#FFCB6B;">&quot;localhost:9999&quot;</span><span style="color:#FFCB6B;">,</span><span style="color:#FFCB6B;">&quot;user-agent&quot;</span><span style="color:#82AAFF;">:</span><span style="color:#FFCB6B;">&quot;curl/7.64.1&quot;</span><span style="color:#FFCB6B;">,</span><span style="color:#FFCB6B;">&quot;accept&quot;</span><span style="color:#82AAFF;">:</span><span style="color:#FFCB6B;">&quot;*/*&quot;</span><span style="color:#FFCB6B;">}%</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>看下抓包情况： <img src="https://ihengshuai-demo1.oss-cn-beijing.aliyuncs.com/005HV6Avgy1h7f9ovwy7kj31k60dwdur.jpg" alt="iShot_2022-10-23_15.45.40.png"> 从上图抓包记录可以将记录分为三部分：①TCP三次握手连接，②HTTP请求相关，③TCP四次挥手</p><p>下面这张图概况了三次握手的摘要 <img src="https://ihengshuai-demo1.oss-cn-beijing.aliyuncs.com/005HV6Avgy1h7faoku3dyj31380lcdrx.jpg" alt="iShot_2022-10-23_16.19.57.png"> 抓包记录： <img src="https://ihengshuai-demo1.oss-cn-beijing.aliyuncs.com/005HV6Avgy1h7f9rj9jobj30ss03qtb1.jpg" alt="iShot_2022-10-23_15.48.12.png"></p><ol><li><p>这里看出两端通信的端口为<code>54987</code>(终端)和<code>9999</code>(服务器)，终端发送<code>SYN</code>类型请求，指明客户端的初始化序号为0，这里的0位相对值，其真实性值为<code>3059428279</code>，并告诉下次的序列号为1，如下图： <img src="https://ihengshuai-demo1.oss-cn-beijing.aliyuncs.com/005HV6Avgy1h7f9zshnzlj311s0go102.jpg" alt="iShot_2022-10-23_15.52.26.png"></p></li><li><p>服务端接收到客户端的SYN数据包后，发送自己的应答SYN包，并指定自己的序列号0(真实值3338838224)，并将<code>客户端的序列号+1发送ACK=1确认包(acknumber=3059428280)</code>，并告诉下次序列号为1，如下图： <img src="https://ihengshuai-demo1.oss-cn-beijing.aliyuncs.com/005HV6Avgy1h7fa53pnh8j312a0jywnv.jpg" alt="iShot_2022-10-23_16.01.16.png"></p></li><li><p>客户端接收到了服务端的SYN数据包和ACK包后，也将服务端的SYN+1(acknumber = 3338838225)作为ACK数据包发送给服务端，就完成了三次握手 <img src="https://ihengshuai-demo1.oss-cn-beijing.aliyuncs.com/005HV6Avgy1h7fagk4km2j31280kewn3.jpg" alt="iShot_2022-10-23_16.11.54.png"></p></li></ol><p>至于ACK值不断加1是为了标识数据包保证接收方的顺序性，因为发送时数据可能乱序，在收到数据后，TCP不会直接把数据交给上层，而会做一个缓存，直到传输完毕将包按顺序组装在上交给应用层。</p><p>三次握手的简单理解： 第一次：客户端发送数据到服务端，服务端接收到后知道客户端的发送能力没问题 第二次：服务端发送数据到客户端，客户端接接收后知道服务端的接收能力正常，发送能力也没问题 第三次：客户端再发送数据到服务端，服务端接收后知道客户端的接收能力没问题</p><p>通过三次握手两端都知道了对方发送和接收没有问题，之后就可以正常通信了。</p><h3 id="四次挥手" tabindex="-1">四次挥手 <a class="header-anchor" href="#四次挥手" aria-label="Permalink to &quot;四次挥手&quot;">​</a></h3><p>当客户端请求毕后就会断开连接，由于为了提高传输效率http使用<code>keep-alive</code>会在一定时间内保持TCP的连接，这里设置HTTP头部<code>connection=close</code>表示请求完毕后立即断开连接。</p><p>来看回收抓包记录： <img src="https://ihengshuai-demo1.oss-cn-beijing.aliyuncs.com/005HV6Avgy1h7fb5u12owj30yg04on1o.jpg" alt="iShot_2022-10-23_16.36.34.png"></p><ol><li>在客户端请求完毕后会发送FIN报文给服务端，包含自己的序列号seq=79和ack=125来确认对方最近一次发送的数据，然后表示我没有其他请求了，这时客户端进入<code>FIN_WAIT1</code>状态 <img src="https://ihengshuai-demo1.oss-cn-beijing.aliyuncs.com/005HV6Avgy1h7fbdyp9zzj31200hyjyp.jpg" alt="iShot_2022-10-23_16.44.22.png"></li><li>服务端接收到数据包后，发送包含自己的seq=125和ack=80的ACK报文给客户端，表示我知道了，并通知上层应用另一端发起了关闭操作，此时服务端并不会立马发起关闭操作，也就是发送服务端的FIN报文，此时服务端进入<code>CLOSE_WAIT</code>状态，客户端进入<code>FIN_WAIT2</code>状态 <img src="https://ihengshuai-demo1.oss-cn-beijing.aliyuncs.com/005HV6Avgy1h7fbhbhh94j31240hwn4s.jpg" alt="iShot_2022-10-23_16.47.36.png"></li><li>等一会时间服务端再发送包含seq=125，ack=80的FIN报文和ACK报文并期待下一次的ACK序列号为126，表示可以断开连接了，服务端进入<code>LAST_ACK</code>状态 <img src="https://ihengshuai-demo1.oss-cn-beijing.aliyuncs.com/005HV6Avgy1h7fbkn6yf5j311g0g2wlf.jpg" alt="iShot_2022-10-23_16.50.48.png"></li><li>客户端接收到后会在发送ack=126的ACK报文，最后断开连接，此时客户端进入<code>TIMED_WAIT</code>状态，服务端将会进入<code>CLOSED</code>状态，最后再等<code>2MSL</code>(Maximum Segment Lifetime)客户端也进入<code>CLOSED</code>状态 <img src="https://ihengshuai-demo1.oss-cn-beijing.aliyuncs.com/005HV6Avgy1h7fbm614fxj311k0gatem.jpg" alt="iShot_2022-10-23_16.52.15.png"></li></ol><p>通过上面的分析已经对四次挥手有了更深理解了，下面再画个图总结下 <img src="https://ihengshuai-demo1.oss-cn-beijing.aliyuncs.com/005HV6Avgy1h7fccd75wkj31gi0qutn3.jpg" alt="iShot_2022-10-23_17.17.26.png"></p><p>以上就是TCP挥手的基本原理了。这里解释一下两个问题：</p><ol><li>为什么挥手要四次，而握手是3次？ 因为握手时服务端直接确认连接不需要等待，所以发送<code>SYN+ACK数据包</code>。而挥手时服务端接受到了客户端的<code>FIN</code>包后，知道客户端没有请求了但还可以继续接受数据包，服务端也并不能立马关闭连接，因为服务端此时可能数据并没有发送完毕，需要等待发送完毕后才会主动发送<code>FIN</code>包请求断开。</li><li>为什么客户端挥手后发送了<code>ACK</code>包还要等<code>2MSL</code>段时间才会进入<code>CLOSED</code>状态？ 这是因为当客户端发送了<code>ACK</code>报文后，有可能有丢失的包的可能，这导致服务端还没有收到客户端的<code>ACK</code>报文，会认为自己发的<code>FIN</code>报文可能客户端没有收到，于是会再发一个给客户端，客户端会再发送<code>ACK</code>报文，重新计时<code>2MSL</code>，等服务端接收到<code>ACK</code>报文后，则不会再发送<code>FIN</code>报文，<code>2MSL</code>时间段后客户端正式进入<code>CLOSED</code>状态。</li></ol><h2 id="http协议" tabindex="-1">HTTP协议 <a class="header-anchor" href="#http协议" aria-label="Permalink to &quot;HTTP协议&quot;">​</a></h2><p>由于HTTP协议是基于TCP协议的，所以上面我们用<code>curl</code>发起的是HTTP请求，那我们看下http请求过程。 <img src="https://ihengshuai-demo1.oss-cn-beijing.aliyuncs.com/005HV6Avgy1h7fcums2gkj30vq04edig.jpg" alt="iShot_2022-10-23_17.35.00.png"></p><ul><li>首先客户端发送GET请求给服务端</li><li>服务端发送TCP的ACK的数据包确认已经收到请求了</li><li>服务端发送http响应，状态码200</li><li>客户端接收到后，发送TCP的ACK数据包表示已经接收到了数据</li></ul><p>我们通过跟踪HTTP数据流看下细节： <img src="https://ihengshuai-demo1.oss-cn-beijing.aliyuncs.com/005HV6Avgy1h7fcww5re2j311m0f2afi.jpg" alt="iShot_2022-10-23_17.37.10.png"></p><p>到这里已经了解了如何用wireshark分析ARP协议、TCP协议和HTTP协议了，当然这只是简单的讲解，其他协议都大同小异，更多功能自己可以动手试试。</p><h2 id="统计" tabindex="-1">统计 <a class="header-anchor" href="#统计" aria-label="Permalink to &quot;统计&quot;">​</a></h2><p>统计可以对网络数据进行不同维度的统计，如：HTTP、TCP、UDP、DNS等相关的统计，这些统计比较简单，自己动手试试就会明白。</p><h2 id="小结" tabindex="-1">小结 <a class="header-anchor" href="#小结" aria-label="Permalink to &quot;小结&quot;">​</a></h2><p>本篇介绍了wireshark的基本使用，并通过对ARP协议、TCP协议和HTTP协议的分析，已经掌握了分析数据包的基本能力，并加强了相关协议的理解，其他相关的协议都大同小异。到本篇已经讲了3款抓包软件了，相信大家对抓包已经不陌生了，希望通过这些抓包工具可以提高你的分析能力和对原理的认识。</p>`,87);function r(h,d,y,u,g,m){const n=a("Reward"),e=a("Gitalk");return c(),l("div",null,[i,s(n),s(e)])}const D=p(t,[["render",r]]);export{F as __pageData,D as default};
