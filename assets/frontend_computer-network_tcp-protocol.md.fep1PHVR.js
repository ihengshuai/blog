import{_ as l,c as p,J as s,V as o,o as c,G as a}from"./chunks/framework.SV1ROkXV.js";const T=JSON.parse('{"title":"TCP协议","description":"TCP（Transmission Control Protocol，传输控制协议）是一种在计算机网络中常用的协议，它是一种面向连接的、可靠的、基于字节流的传输层协议，本文来了解TCP首部信息、连接与断开、可靠传输、流量控制等等","frontmatter":{"title":"TCP协议","description":"TCP（Transmission Control Protocol，传输控制协议）是一种在计算机网络中常用的协议，它是一种面向连接的、可靠的、基于字节流的传输层协议，本文来了解TCP首部信息、连接与断开、可靠传输、流量控制等等","keywords":"TCP协议,三次握手,四次挥手,滑动窗口,TCP流量控制,TCP拥塞控制,TCP可靠传输,TCP分段传输,TCP超时重传","logo":"https://ihengshuai-demo1.oss-cn-beijing.aliyuncs.com/icon-tcp.png"},"headers":[],"relativePath":"frontend/computer-network/tcp-protocol.md","filePath":"frontend/computer-network/tcp-protocol.md","lastUpdated":1709440279000}'),r={name:"frontend/computer-network/tcp-protocol.md"},t=o(`<h1 id="tcp协议" tabindex="-1">TCP协议 <a class="header-anchor" href="#tcp协议" aria-label="Permalink to &quot;TCP协议&quot;">​</a></h1><p>TCP（Transmission Control Protocol，传输控制协议）是一种在计算机网络中常用的协议，它是一种<u>面向连接的、可靠的、基于字节流的传输层协议。TCP协议主要负责对数据进行分段、组装、传输和确认，以保证数据的可靠传输</u>。</p><h2 id="特点" tabindex="-1">特点 <a class="header-anchor" href="#特点" aria-label="Permalink to &quot;特点&quot;">​</a></h2><ul><li>可靠性：TCP协议可以保证数据的可靠传输，通过数据分段、校验和、确认机制等手段来确保数据不会丢失、损坏或重复</li><li>面向连接：TCP协议在传输数据之前需要先建立连接，传输完成后再释放连接。这种连接方式可以保证数据的有序传输，避免数据混乱</li><li>流式传输：TCP协议是基于字节流的传输层协议，将数据按照字节流方式分段传输，不需要考虑数据的长度和格式</li><li>拥塞控制：TCP协议可以根据网络状态来控制数据的发送速度，避免网络拥塞导致数据丢失和延迟</li></ul><h2 id="tcp首部" tabindex="-1">TCP首部 <a class="header-anchor" href="#tcp首部" aria-label="Permalink to &quot;TCP首部&quot;">​</a></h2><p><img src="https://ihengshuai-demo1.oss-cn-beijing.aliyuncs.com/tcp-header-2020-04121011.svg" alt=""></p><ul><li>源端口：发送方端口，长度为2个字节16位，因此最大值为<code>2的16次方</code>65536 - 1，故TCP的端口范围为<code>0 ~ 65535</code></li><li>目标端口：另一方的端口，范围同上</li><li>序列号：代表着数据的位置，最大序号为<code>2的32次方-1</code>，每发一次数据就要累加一次该数据的长度，当序号超过最大值又会从0开始。序列号不一定从0或1开始，而是从建立连接的随机数作为其初始值，在建立连接和断开连接时发送的SYN包和FIN包虽然并不携带数据，但是也会作为1个字节增加对应的序列号。</li><li>确认号：指下一次应该收到的数据的序列号</li><li>数据偏移：字段长4位，单位为4字节，代表着数据包开始的位置，也可以理解成TCP首部总长度。从图中可以知道首部的固定长度为20字节，在没有可选数据时其最小值为5(二进制表示<code>0101</code>)，最大值<code>2的4次方减1</code>(二进制<code>1111</code>)15再乘4为60字节，由此可知可选部分的最大长度为40字节</li><li>保留位：4位长度，以后扩展使用，到目前为止还没有任何用处</li><li>控制位：8位长度，由左到右分别是<code>CWR(Congestion Window Reduced)</code>、<code>ECE(Explicit Congestion Notification)</code>、<code>URG(Urgent Flag)</code>、<code>ACK(Acknovledgement Flag)</code>、<code>PSH(Push Flag)</code>、<code>RST(Reset Flag)</code>、<code>SYN(Synchronize Flag)</code>、<code>FIN(Fin Flag)</code>，当他们的值为1时都表示一定的含义 <ul><li>CWR：减小拥塞窗口，发送方降低发送速率</li><li>ECE：ECN回显，发送方接受到了一个更早的拥塞通知（ECN是一种拥塞控制机制，用于在发生拥塞时通知TCP发送方降低发送速率，从而避免网络拥塞）</li><li>URG：表示当前数据需要紧急处理</li><li>ACK：表示确认需要有效，也就是ACK为1时上图中的确认号才会有效</li><li>PSH：表示数据需要立刻传给上层协议</li><li>RST：表示连接出现非常严重的错误必须重新连接</li><li>SYN：表示希望建立连接，并将当前的序号作为初始值</li><li>FIN：表示希望断开连接不会有数据发送了</li></ul></li><li>窗口：字段长为16位，用于通知从确认号开始能够接受的数据大小，如果窗口的值为0时表示可以发送窗口侦测，通常情况下TCP会根据窗口大小进行分段传输，每段最大传输数据大小(MSS)为1460，实际情况的最大长度为1448（减去12字节的时间戳选项）</li><li>校验和：端到端校验机制确保数据的正确性，由发送方通过头部、数据计算得到的校验和，接收方方会重新校验进行对比</li><li>紧急指针：在URG控制位为1时有效，该字段的数值表示数据中的紧急数据，也就是说从数据的开始到紧急指针的位置为紧急数据，因此紧急指针也代表了紧急数据的末尾</li><li>选项：选项类型(无操作、最大段大小MSS、窗口缩放因子、时间戳等等)，每个选项的第一个字节为种类指明选项的类型，种类为0和1的选项仅占1字节，其他种类选项根据种类来确定字节数，种类1允许发送者用多个4字节组填充字段</li></ul><div class="warning custom-block"><p class="custom-block-title">注意</p><p>在老版本的TCP协议中可能只会存在6为控制位，而CWR、ECE控制位可能不存在，新版本都会有8位控制位</p></div><p><img src="https://ihengshuai-demo1.oss-cn-beijing.aliyuncs.com/image-20230412075451246.png" alt=""></p><p>以上的字段明细都可以使用wireshark抓包工具捕获到，如果你对此工具还不熟悉可以参考我的<a href="/frontend/debug-skill/wireshark.html">「wireshark网络抓包」</a>一文</p><h2 id="连接与终止" tabindex="-1">连接与终止 <a class="header-anchor" href="#连接与终止" aria-label="Permalink to &quot;连接与终止&quot;">​</a></h2><p>TCP是可靠传输协议，其数据传输前通信双方必须建立一条连接，总体来说TCP通信是个复杂的过程（超时重传、流量控制、分包组装等等），整体通信大致过程示意图如下：</p><p><img src="https://ihengshuai-demo1.oss-cn-beijing.aliyuncs.com/TCP-transfers-20200412111.svg" alt=""></p><h3 id="三次握手" tabindex="-1">三次握手 <a class="header-anchor" href="#三次握手" aria-label="Permalink to &quot;三次握手&quot;">​</a></h3><p>关于TCP的三次握手和四次挥手是常问的考点，搞清楚它非常简单，这里总结下二者。TCP的连接需要三个步骤：发起端发送SYN、接收端发送SYN+ACK、发送端发送ACK。为什么需要三次呢？一次行不行？答案是否定的，三次正好符合可靠传输的特点。这就好比2人打电话，甲方打给乙方，甲方问你是乙方吗，乙方回答我是那你是谁呢，甲方再次回乙方说我是谁，这样下来双方都知道对方的身份并且知道电话已经打通了，可以收发数据。而TCP连接也是这样的，下方是三次握手连接的示意图：</p><p><img src="https://ihengshuai-demo1.oss-cn-beijing.aliyuncs.com/tcp-handshakes-20200412111.svg" alt=""></p><ol><li>刚开始Client处于close状态，Server处于Listen状态</li><li>Client主动打开发送<code>SYN=1、Seq=x</code>请求表示主动连接（注意：<u>seq在初始化时是个随机数，它会根据时间戳变化，超时重传时使用相同的seq，新的连接会生成新的序列号，来避免历史或其他连接的错误问题</u>），此时Client进入<code>SYN_SENT</code>状态</li><li>Server接受到客户端的<code>SYN</code>请求后，需要应答Client并发送<code>SYN=1、ACK=1、Seq=y</code>请求，其中确认号为<code>x+1</code>且有效期望下一次客户端的发送序列号应为<code>x+1</code>，而<code>SYN</code>表示也想连接Client且序号为<code>y</code>，此时Server进入<code>SYN_RCVD</code>状态</li><li>Client收到Server的<code>ACK</code>响应后进入<code>ESTABLISHED</code>状态表示已连接(半连接状态)，然后发送<code>Seq=x+1、ACK=1</code>的请求，序列号为<code>y+1</code>且有效，表示确认了Server的连接请求，并期望Server下一次发送的序号为<code>y+1</code></li><li>Server收到客户端的<code>ACK</code>响应后也进入<code>ESTABLISHED</code>状态，双方进入全连接状态，三次握手完毕可以进行数据传输了</li></ol><p>抓包结果： <img src="https://ihengshuai-demo1.oss-cn-beijing.aliyuncs.com/image-20230415093235503.png" alt=""></p><blockquote><p>TCP握手期间虽然没有真实的数据进行传输，但在这期间会进行相关重要数据的约定，如：窗口大小、MSS等有用的信息</p></blockquote><h3 id="重置连接" tabindex="-1">重置连接 <a class="header-anchor" href="#重置连接" aria-label="Permalink to &quot;重置连接&quot;">​</a></h3><p>三次握手是TCP连接的正常过程，但还有其他非正常的连接出现严重的连接错误，此时就会通过标记RST来重置连接，比如主机A使用telnet连接主机B的某个未开放端口，就会被主机B拒绝：</p><div class="language-sh line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki material-theme-palenight vp-code"><code><span class="line"><span style="color:#676E95;font-style:italic;"># 使用主机A192.168.10.8登录 主机B192.168.10.9:8080</span></span>
<span class="line"><span style="color:#FFCB6B;">➜</span><span style="color:#C3E88D;"> telnet </span><span style="color:#F78C6C;">192.168</span><span style="color:#C3E88D;">.10.9 </span><span style="color:#F78C6C;">8080</span></span>
<span class="line"><span style="color:#FFCB6B;">Trying</span><span style="color:#F78C6C;"> 192.168</span><span style="color:#C3E88D;">.10.9...</span></span>
<span class="line"><span style="color:#FFCB6B;">telnet:</span><span style="color:#C3E88D;"> connect to address </span><span style="color:#F78C6C;">192.168</span><span style="color:#C3E88D;">.10.9: Connection refused</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>当主机B接受到TCP连接请求时被认为成错误的连接，此时主机B会主动发送一个RST的响应，表示连接错误，需要重新连接，可以使用抓包工具查看： <img src="https://ihengshuai-demo1.oss-cn-beijing.aliyuncs.com/image-20230412111304449.png" alt=""></p><h3 id="连接队列" tabindex="-1">连接队列 <a class="header-anchor" href="#连接队列" aria-label="Permalink to &quot;连接队列&quot;">​</a></h3><p>上面的三次握手只是简单的概述了主要的连接过程，在真实环境中存在请求队列的概念，如同时并发多个TCP请求，就会将其排列成队列进行处理</p><p>在TCP连接中存在两个重要的队列<code>SYN队列(半连接队列)</code>和<code>Accept队列(全连接队列)</code>，它们分别用于<u>处理连接请求和已经建立连接的数据传输</u></p><ul><li>SYN队列：用于存储SYN（同步）请求的队列。当一个客户端请求与服务器建立TCP连接时，它会向服务器发送一个SYN包。服务器在收到SYN包后，将在SYN队列中排队等待确认，并向客户端发送一个SYN-ACK包作为确认</li><li>Accept队列：用于存储已经建立连接的队列(未被上层应用程序使用)。当服务器收到客户端第三次握手的ACK请求后，客户端和服务器之间的连接就建立了，此时连接会被添加到accept队列中，等待应用程序使用</li></ul><p>大致处理过程示意图如下： <img src="https://ihengshuai-demo1.oss-cn-beijing.aliyuncs.com/tcp-connect-queue-20200412111.svg" alt=""> 首先Client主动发送<code>SYN</code>连接请求，Server收到后创建半连接对象将其放入<code>SYN队列</code>，Server发送<code>ACK+SYN</code>给Client后，直到收到Client的<code>ACK</code>响应后，创建全连接对象将其连接放入<code>Accept队列</code>，最后由应用程序接受处理</p><p>SYN队列的的最大限制通常是1000，Accept队列的最大限制通常是128，可以通过以下方式查看：</p><div class="language-sh line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki material-theme-palenight vp-code"><code><span class="line"><span style="color:#676E95;font-style:italic;"># 查看syn队列最大值</span></span>
<span class="line"><span style="color:#FFCB6B;">➜</span><span style="color:#C3E88D;"> cat /proc/sys/net/core/netdev_max_backlog</span></span>
<span class="line"><span style="color:#FFCB6B;">1000</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;"># accept队列最大值</span></span>
<span class="line"><span style="color:#FFCB6B;">➜</span><span style="color:#C3E88D;"> cat /proc/sys/net/ipv4/tcp_max_syn_backlog</span></span>
<span class="line"><span style="color:#FFCB6B;">128</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>总的来说两个队列并不是很大，但实际情况中由于CPU、内存等相关因素的影响，我们的应用程序可能达不到很高的并发处理请求，因此TCP的请求就会被延时，或当SYN、Accept队列溢出时，Server也会忽略掉Client的SYN请求包，根据重传机制Client等待一段时间重新发送SYN，此时Server表现出<code>繁忙</code>的状态</p><h3 id="syn泛洪" tabindex="-1">SYN泛洪 <a class="header-anchor" href="#syn泛洪" aria-label="Permalink to &quot;SYN泛洪&quot;">​</a></h3><p>SYN泛洪也称SYN攻击，是TCP常见的网络攻击手段，其利用TCP连接三次握手的第一阶段，当Client向Server疯狂发送SYN请求，却不响应Server的ACK+SYN请求时，Server的SYN队列会很快被打满，从而主动丢弃后面的SYN请求，也就无法进行正常的TCP连接了，大量的SYN请求也会消耗Server的资源，产生不正常的消耗</p><p>如何避免SYN攻击呢，可以从<code>防火墙</code>、<code>SYN Cookies</code>、<code>减小SYN队列</code>、<code>SYN ACK重传次数</code>等着手：</p><ol><li><p>开启SYN Cookies：</p><p>什么是SYN Cookies？当SYN队列溢出时，如果再收到SYN请求不会为其分配任何存储资源，而只有当SYN+ACK报文段被确认时才分配到Accept队列里。SYN Cookies是由Server通过一定的算法加随机值计算而来，再作为序列号发送给Client，Server收到Client的ACK报文后会校验合法性，如果合法将会放入Accept队列，否则直接丢弃，这样就绕过了SYN队列资源。</p><p>可以通过以下方式设置syncookies：</p><div class="language-sh line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki material-theme-palenight vp-code"><code><span class="line"><span style="color:#676E95;font-style:italic;"># 0 表示关闭</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;"># 1 SYN队列溢出时开启</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;"># 2 永久开启</span></span>
<span class="line"><span style="color:#FFCB6B;">➜</span><span style="color:#C3E88D;"> cat /proc/sys/net/ipv4/tcp_syncookies</span></span>
<span class="line"><span style="color:#FFCB6B;">1</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><blockquote><p>服务器通常用下面的方法设置初始序列号：首5位是t模32的结果，其中t是一个32位的计数器，每隔 64秒增1；接着3位是对服务器最大段大小(8种可能之一)的编码值；剩余的24位保存了 4元组与t值的散列值，该数值是根据服务器选定的散列加密算法计算得到的。Server根据其中的t值可以计算出与加密 的散列值相同的结果，那么服务器才会为该SYN重新构建队列</p></blockquote></li><li><p>减小SYN ACK重传次数</p><p>减小重传次数让其达到最大重传次数时，释放掉SYN资源断开连接，SYN ACK重传次数由linux内核决定的，可以通过以下方式进行查看和设置：</p><div class="language-sh line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki material-theme-palenight vp-code"><code><span class="line"><span style="color:#FFCB6B;">➜</span><span style="color:#C3E88D;"> cat /proc/sys/net/ipv4/tcp_synack_retries</span></span>
<span class="line"><span style="color:#FFCB6B;">5</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div></li></ol><h3 id="四次挥手" tabindex="-1">四次挥手 <a class="header-anchor" href="#四次挥手" aria-label="Permalink to &quot;四次挥手&quot;">​</a></h3><p>TCP断开需要4步完成 <img src="https://ihengshuai-demo1.oss-cn-beijing.aliyuncs.com/tcp-discon-20200412111.svg" alt=""></p><ol><li>假如Client想要释放连接将会发送<code>FIN</code>请求给Server端，接着进入<code>FIN_WAIT_1</code>状态</li><li>Server收到Client的<code>FIN</code>请求后，给Client回了一个<code>ACK</code>响应，进入<code>CLOSED_WAIT</code>状态</li><li>Client收到Server的<code>ACK</code>响应后，进入<code>FIN_WAIT_2</code>状态，等待Server发送<code>FIN</code>请求</li><li>Server处理完数据发送<code>FIN</code>请求给Client，进入<code>LAST_ACK</code>状态</li><li>Client终于等到了Server的<code>FIN</code>请求，赶紧给Server回了一个<code>ACK</code>响应，紧接着进入<code>TIME_WAIT</code>状态，在等待<code>2MSL</code>时间后也会进入<code>CLOSE</code>状态</li><li>Server收到Client的<code>ACK</code>响应后进入<code>CLOSE</code>状态，此时Server已经完全关闭</li></ol><p>抓包结果： <img src="https://ihengshuai-demo1.oss-cn-beijing.aliyuncs.com/image-20230415093526896.png" alt=""></p><p>💡<strong>为什么看到的是3次挥手？</strong></p><p>不是说TCP断开需要4次挥手吗？为什么实际抓包的结果却是3次就完成了？这里就需要了解TCP的延时确认机制</p><p>TCP的<code>延迟确认（Delayed ACK）</code>是一种优化TCP传输性能的机制。TCP协议默认采用延迟确认机制，即接收方不会立即发送确认消息，而是等待一定时间（通常是200ms），看是否需要返回数据，如果无需数据就会等待一会看后面的请求是否需要返回数据，便一起返回发送一个确认消息，以减少确认消息的数量和网络负载，否则需要数据就会立刻返回ACK</p><p>而三次回收的情况通常是接收端不需要再发送数据了，根据延时确认机制便会将2、3次挥手(ACK&amp;FIN)合并成一次数据返回，这就是为什么实际网络中看到的是3次挥手的原因。可以通过修改TCP的延迟发送值来禁用此功能，这里不再展开</p><p>💡<strong>什么是MSL？为啥需要2MSL</strong></p><p>MSL(Maximum Segment Lifetime)是报文最大生存时间，也就是说网络中最大的存活时间，否则将会丢弃。<u>MSL的时间通常大于TTL的跳数时间，IP的传输存活时间是基于TTL的跳数，每过一个路由器TTL都会减去1，直到为0时将会丢弃报文，同时发送<code>ICMP</code>报文通知源主机目标不可达</u></p><p>MSL默认值通常为<code>30</code>，TTL的默认跳数为<code>64</code>，系统认为30s内IP可以被转发64次。为什么是2MSL呢？2MSL是从Client接收到Server的FIN报文后发送ACK报文开始计算的，假如ACK报文由于网络原因在MSL时间内没有到达Server，Server会触发超时重传机制再次发送FIN报文给Client，所以2MSL是最保险的时间，当Client等待2MSL内没有收到任何Server的包就会被关闭掉</p><p>通过以下方式查看系统默认的TTL跳数和MSL时间</p><div class="language-sh line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki material-theme-palenight vp-code"><code><span class="line"><span style="color:#676E95;font-style:italic;"># TTL 默认跳数</span></span>
<span class="line"><span style="color:#FFCB6B;">➜</span><span style="color:#C3E88D;"> cat /proc/sys/net/ipv4/ip_default_ttl</span></span>
<span class="line"><span style="color:#FFCB6B;">64</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;"># FIN默认超时时间(2MSL时间)</span></span>
<span class="line"><span style="color:#FFCB6B;">➜</span><span style="color:#C3E88D;"> cat /proc/sys/net/ipv4/tcp_fin_timeout</span></span>
<span class="line"><span style="color:#FFCB6B;">60</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>💡<strong>有趣的是</strong>处于<code>TIME_WAIT(2MSL)</code>状态下的端口还不能重新被使用！虽然Client已经收到Server的FIN报文并发送了ACK报文确定要断开连接了，但在TIME_WAIT期间其端口还是不能被使用（尽管Server可能已经被关闭了），这个原因其实和为啥要等待2MSL道理一样，都是为了避免2MSL期间Server重传FIN报文。我们来验证下端口不可用：</p><div class="language-sh line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki material-theme-palenight vp-code"><code><span class="line"><span style="color:#676E95;font-style:italic;"># 访问本地nginx</span></span>
<span class="line"><span style="color:#FFCB6B;">➜</span><span style="color:#C3E88D;"> curl localhost</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;"># 查看TCP的连接状态，可以很明显本地的 \`33196\` 端口关联了 80端口，即curl随机选用了 33196 端口访问nginx</span></span>
<span class="line"><span style="color:#FFCB6B;">➜</span><span style="color:#C3E88D;"> netstat -ant </span><span style="color:#89DDFF;">|</span><span style="color:#FFCB6B;"> grep</span><span style="color:#F78C6C;"> 80</span></span>
<span class="line"><span style="color:#FFCB6B;">tcp</span><span style="color:#F78C6C;">        0</span><span style="color:#F78C6C;">      0</span><span style="color:#F78C6C;"> 0.0</span><span style="color:#C3E88D;">.0.0:80              </span><span style="color:#F78C6C;">0.0</span><span style="color:#C3E88D;">.0.0:</span><span style="color:#BABED8;">*</span><span style="color:#C3E88D;">               LISTEN</span></span>
<span class="line highlighted"><span style="color:#FFCB6B;">tcp</span><span style="color:#F78C6C;">        0</span><span style="color:#F78C6C;">      0</span><span style="color:#F78C6C;"> 127.0</span><span style="color:#C3E88D;">.0.1:33196         </span><span style="color:#F78C6C;">127.0</span><span style="color:#C3E88D;">.0.1:80            TIME_WAIT</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;"># 使用nodejs监听33196端口，抛出异常 端口被占用</span></span>
<span class="line"><span style="color:#FFCB6B;">➜</span><span style="color:#C3E88D;"> node index.js</span></span>
<span class="line"><span style="color:#FFCB6B;">events.js:377</span></span>
<span class="line"><span style="color:#FFCB6B;">      throw</span><span style="color:#C3E88D;"> er</span><span style="color:#89DDFF;">;</span><span style="color:#FFCB6B;"> //</span><span style="color:#C3E88D;"> Unhandled </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">error</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;"> event</span></span>
<span class="line"><span style="color:#FFCB6B;">      ^</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FFCB6B;">Error:</span><span style="color:#C3E88D;"> listen EADDRINUSE: address already in use :::33196</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p>上述等再次查看33196已经被完全断开时就可以正常启动了</p><h3 id="查看tcp状态" tabindex="-1">查看TCP状态 <a class="header-anchor" href="#查看tcp状态" aria-label="Permalink to &quot;查看TCP状态&quot;">​</a></h3><p>可以在主机上通过<code>netstat</code>命令查看tcp的连接状态，netstat是一个用于显示网络状态和统计信息的命令行工具，可以用来查看系统的网络连接、路由表、接口状态等</p><div class="language-sh line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki material-theme-palenight vp-code"><code><span class="line"><span style="color:#FFCB6B;">➜</span><span style="color:#C3E88D;"> netstat -antp </span><span style="color:#89DDFF;">|</span><span style="color:#FFCB6B;"> more</span></span>
<span class="line"><span style="color:#FFCB6B;">Active</span><span style="color:#C3E88D;"> Internet connections </span><span style="color:#89DDFF;">(</span><span style="color:#FFCB6B;">servers</span><span style="color:#C3E88D;"> and established</span><span style="color:#89DDFF;">)</span></span>
<span class="line"><span style="color:#FFCB6B;">Proto</span><span style="color:#C3E88D;"> Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name</span></span>
<span class="line"><span style="color:#FFCB6B;">tcp</span><span style="color:#F78C6C;">        0</span><span style="color:#F78C6C;">      0</span><span style="color:#F78C6C;"> 0.0</span><span style="color:#C3E88D;">.0.0:111             </span><span style="color:#F78C6C;">0.0</span><span style="color:#C3E88D;">.0.0:</span><span style="color:#BABED8;">*</span><span style="color:#C3E88D;">               LISTEN      </span><span style="color:#F78C6C;">872</span><span style="color:#C3E88D;">/rpcbind</span></span>
<span class="line"><span style="color:#FFCB6B;">tcp</span><span style="color:#F78C6C;">        0</span><span style="color:#F78C6C;">      0</span><span style="color:#F78C6C;"> 0.0</span><span style="color:#C3E88D;">.0.0:80              </span><span style="color:#F78C6C;">0.0</span><span style="color:#C3E88D;">.0.0:</span><span style="color:#BABED8;">*</span><span style="color:#C3E88D;">               LISTEN      </span><span style="color:#F78C6C;">1229</span><span style="color:#C3E88D;">/nginx: master</span></span>
<span class="line"><span style="color:#FFCB6B;">tcp</span><span style="color:#F78C6C;">        0</span><span style="color:#F78C6C;">      0</span><span style="color:#F78C6C;"> 0.0</span><span style="color:#C3E88D;">.0.0:22              </span><span style="color:#F78C6C;">0.0</span><span style="color:#C3E88D;">.0.0:</span><span style="color:#BABED8;">*</span><span style="color:#C3E88D;">               LISTEN      </span><span style="color:#F78C6C;">1211</span><span style="color:#C3E88D;">/sshd</span></span>
<span class="line"><span style="color:#FFCB6B;">tcp</span><span style="color:#F78C6C;">        0</span><span style="color:#F78C6C;">      0</span><span style="color:#F78C6C;"> 127.0</span><span style="color:#C3E88D;">.0.1:25            </span><span style="color:#F78C6C;">0.0</span><span style="color:#C3E88D;">.0.0:</span><span style="color:#BABED8;">*</span><span style="color:#C3E88D;">               LISTEN      </span><span style="color:#F78C6C;">1454</span><span style="color:#C3E88D;">/master</span></span>
<span class="line"><span style="color:#FFCB6B;">tcp</span><span style="color:#F78C6C;">        0</span><span style="color:#F78C6C;">      0</span><span style="color:#F78C6C;"> 0.0</span><span style="color:#C3E88D;">.0.0:10010           </span><span style="color:#F78C6C;">0.0</span><span style="color:#C3E88D;">.0.0:</span><span style="color:#BABED8;">*</span><span style="color:#C3E88D;">               LISTEN      </span><span style="color:#F78C6C;">1229</span><span style="color:#C3E88D;">/nginx: master</span></span>
<span class="line"><span style="color:#FFCB6B;">tcp</span><span style="color:#F78C6C;">        0</span><span style="color:#F78C6C;">    196</span><span style="color:#F78C6C;"> 192.168</span><span style="color:#C3E88D;">.10.9:22         </span><span style="color:#F78C6C;">192.168</span><span style="color:#C3E88D;">.10.1:65308      ESTABLISHED </span><span style="color:#F78C6C;">1691</span><span style="color:#C3E88D;">/sshd: root@pts</span></span>
<span class="line"><span style="color:#FFCB6B;">tcp</span><span style="color:#F78C6C;">        0</span><span style="color:#F78C6C;">      0</span><span style="color:#F78C6C;"> 127.0</span><span style="color:#C3E88D;">.0.1:33196         </span><span style="color:#F78C6C;">127.0</span><span style="color:#C3E88D;">.0.1:80            TIME_WAIT   -</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>可以从上看出tcp监听的端口号、进程、连接状态等等。如：nginx监听了80端口、ssh监听了22端口，22端口和65308端口保持连接(这里我在主机用terminal连接了虚拟机)处于ESTABLISHED建立状态，33196端口和80端口已经处于断开但还在TIME_WAIT状态</p><h3 id="半连接、半断开、半打开" tabindex="-1">半连接、半断开、半打开 <a class="header-anchor" href="#半连接、半断开、半打开" aria-label="Permalink to &quot;半连接、半断开、半打开&quot;">​</a></h3><p>要了解这几种状态含义需要明白TCP是个全双工连接协议，它提供了全双工的数据传输能力。全双工连接指的是通信双方可以同时发送和接收数据，而不受对方数据传输的影响。这意味着，在一个TCP连接中，数据可以沿着两个方向同时传输，而不需要等待对方的回复</p><p>半连接：在TCP三次握手时，Client如果不回复Server端ACK报文时，Server端就处于SYN_RCVD状态，消耗Server端的资源，常见的SYN攻击就是基于半连接漏洞产生的</p><p>半断开：在TCP四次挥手期间，Client发送了FIN报文后，却一直等不到Server的FIN报文，此时Client只能收到报文而不能发送报文</p><p>半打开：正常的TCP连接双方都可以收发数据报文，假如在某时间段两端不进行任何数据传输，而一端由于某种原因断开了且不发送任何FIN报文，另一端也不会知道是不是断开了，这时就处于半打开状态。而系统内核一般对TCP有一个保活机制(KeepAlive)来心跳检测是否还处于连接状态，当TCP在指定时间不发送任何数据，系统则认为已断开连接</p><div class="warning custom-block"><p class="custom-block-title">注意</p><p>HTTP也有一个KeepAlive的概念，但与TCP的KeepAlive完全不同；HTTP的KeepAlive是开启长连接，在HTTP/1.1默认会开启，主要是提供HTTP请求可以在同一个TCP连接上完成，减小网络开支；而TCP的KeepAlive是个保活机制，在长时间没有进行数据传输时用来探测是否还处于连接状态</p></div><h2 id="数据传输" tabindex="-1">数据传输 <a class="header-anchor" href="#数据传输" aria-label="Permalink to &quot;数据传输&quot;">​</a></h2><p>我们知道TCP是个可靠传输协议，那么它是如何实现数据传输的可靠性的呢？通常情况下TCP会对传输的数据进行分段并进行编号，当接受方收到数据后重新进行组装。若在传输的过程中出现了丢包，发送端便会重传丢失的包，其具体实现看下一小节</p><h3 id="分段传输" tabindex="-1">分段传输 <a class="header-anchor" href="#分段传输" aria-label="Permalink to &quot;分段传输&quot;">​</a></h3><p>TCP协议的每段最大数据长度通常被称为<code>MSS(Maximum Segment Size)</code>1460，这个值是根据IP层<code>MTU（Maximum Transmission Unit）</code>最大传输单元计算的，MTU值一般为1500，如果过大会造成网络中路由器的缓冲压力，当IP层所传输的数据大小大于MTU时就会进行IP分片</p><p>如果IP分片传输中有一个IP片丢失了就会重传所有的IP片段，这无疑会浪费网络资源。所以TCP为了不让数据在IP分片，通常设置为每片IP最大数据承载大小也称为MSS。<u>MTU的值为1500字节，IP头占用20字节，TCP头占用20字节，因此MSS的值通常为1500-20-20=1460字节</u></p><p>可以通过设备上的某个网卡查看MTU大小：</p><div class="language-sh line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki material-theme-palenight vp-code"><code><span class="line"><span style="color:#FFCB6B;">➜</span><span style="color:#C3E88D;"> cat /sys/class/net/ens160/mtu</span></span>
<span class="line"><span style="color:#FFCB6B;">1500</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>在实际中MSS的值通常都是1448比1460少了12个字节，这通常是TCP的头部选项部分会多12字节的时间戳等信息，其用来服务超时重传等功能</p><h3 id="滑动窗口" tabindex="-1">滑动窗口 <a class="header-anchor" href="#滑动窗口" aria-label="Permalink to &quot;滑动窗口&quot;">​</a></h3><p>TCP的数据可靠传输类似于一问一答的形式，每发送一个数据包会通过另一方的确认来判断是否丢包，但如果每次只能发送一个数据包将大大提高时延，因此TCP中引入了窗口的概念</p><p>什么是TCP窗口(Window)？<u>窗口通常用来限制数据包的发送速率，是一个流量控制机制，通过动态改变窗口的大小进行控制发送速率</u>。窗口的大小通常等于接收方的窗口大小，会根据接收方的确认消息动态调整，在三次握手期间虽然没有进行实质的数据传输，但通常都会协商一些有用的信息，其中就包含窗口的大小</p><p>窗口其实是个缓存空间，每一方都会在缓存空间中维护着一些有用的信息，如：已发送的数据、未发送的数据等等。假如发送方的窗口大小为3，那么就会连续发送3个数据包，而不需要等待一个一个确认，同时缓冲区会记录这些已发送和未发送的信息，从而改变窗口大小和位置</p><p>滑动窗口的概念则是调整发送数据的起始位置，TCP在传输数据时会将数据分成多段MSS大小的数据段并进行编号，然后便会以窗口大小为基本单位按顺序发送数据，因此窗口范围内的数据发送期必早于窗口后的数据。而窗口内通常会包含多个数据片段，每段数据被实际接收的时间会因为网络原因进行波动，所以发送方收到不同数据片段的ACK时间也会不同，当窗口的前部分被确认后，就会进行窗口滑动，这样后面未在窗口内的数据段就会被放入窗口内等待发送</p><p>大概的滑动窗口示意图如下： <img src="https://ihengshuai-demo1.oss-cn-beijing.aliyuncs.com/tcp-window-20200415111.svg" alt=""></p><p>窗口的大小会根据接收方的确认信息、发送时延、拥塞控制动态改变的，然后来控制发送速率，达到数据传输的可靠、高效，接下来了解下TCP如何完成数据传输的可靠性</p><h2 id="重传机制" tabindex="-1">重传机制 <a class="header-anchor" href="#重传机制" aria-label="Permalink to &quot;重传机制&quot;">​</a></h2><p>大家知道TCP是个可靠的传输协议，所以会有特殊的机制来保证传输数据的可靠性，而其中一个重要的特性就是超时重传。当发送方发送一个报文后在指定的时间内没有收到另一方的响应后，就会认为数据包已经丢失，便会根据重传机制重新发送数据包</p><p>由于网络波动等种种原因，超时重传是避不开的问题，重传有两种机制：<u>基于时间和基于冗余ACK，通常后者比前者更高效</u></p><h3 id="rtt、rto" tabindex="-1">RTT、RTO <a class="header-anchor" href="#rtt、rto" aria-label="Permalink to &quot;RTT、RTO&quot;">​</a></h3><p>了解超时重传前需要知道<code>RTT</code>、<code>RTO</code>两个时间概念</p><p><code>RTT（Round-Trip Time）</code>是指TCP数据包从发送方发送到收到接收到另一方的ACK所需的时间</p><p><code>RTO（Retransmission Timeout）</code>是指TCP发送方在未收到确认的情况下等待重传的时间</p><p>超时重传是根据RTO的时间进行判断的，RTO是根据RTT进行动态计算的，如何确定RTO的时间是非常关键的，通常略大于RTT的时间，过小造成网络资源浪费，过大网络延时偏大，这里不具体展开其实现算法</p><h3 id="超时重传" tabindex="-1">超时重传 <a class="header-anchor" href="#超时重传" aria-label="Permalink to &quot;超时重传&quot;">​</a></h3><p>当TCP发送一个数据包时会启用一个定时器进行倒计时，如果在RTO的时间范围内收到了对方的ACK包则重置定时器不会重传报文，反之没有收到另一方的ACK，则会重新发送数据包，并重启定时器，当超时重传时会把定时器的时间设置为上一次的2倍，也称<code>二进制指数避退(binary exponential backof)</code>，当然不会无线重传下去，会有重传的阈值，当超过了这个值就会断开TCP连接，默认操作系统的重传次数可以通过以下方式进行查看：</p><div class="language-sh line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki material-theme-palenight vp-code"><code><span class="line"><span style="color:#FFCB6B;">➜</span><span style="color:#C3E88D;"> cat /proc/sys/net/ipv4/tcp_syn_retries</span></span>
<span class="line"><span style="color:#FFCB6B;">6</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h3 id="快速重传" tabindex="-1">快速重传 <a class="header-anchor" href="#快速重传" aria-label="Permalink to &quot;快速重传&quot;">​</a></h3><p>快速重传不是基于定时器，而是基于数据进行重传的，通常发生在没有延时的情况下。若TCP累积确认无法返回新的ACK，或者当ACK包含选择确认信息(SACK)表明出现失序报文段时，快速重传会推断出现丢包</p><p>通常来说，当发送端认为接收端可能出现数据丢失时，需要决定发送新(真正丢包的) 数据还是重传所有的问题，处理不好就会造成网络资源的浪费</p><p>TCP提供了<code>SACK（Selective Acknowledgment）</code>方法来提高重传的效率。该机制允许接收方向发送方发送选择性确认（SACK），即确认接收到的连续数据块，同时告知发送方已经接收到丢失数据块的位置，发送方一般都会维护一个缓冲区用来标识已发送的和超时的，从而让发送方只重传丢失的数据块</p><h2 id="拥塞控制" tabindex="-1">拥塞控制 <a class="header-anchor" href="#拥塞控制" aria-label="Permalink to &quot;拥塞控制&quot;">​</a></h2><p>拥塞控制是一种网络流量控制机制，用于避免在网络中发生拥塞而导致网络性能下降或崩溃。该机制通过动态调整发送数据的速率来控制网络中的拥塞程度，并确保网络能够承载传输的数据量</p><p>TCP的拥塞控制算法通常基于网络拥塞的反馈信息，例如丢包、延迟等。当TCP发送方收到这些反馈信息时，它会采取一系列措施来减少发送数据的速率，以避免过多的数据流入网络中而导致拥塞。<u>通过改变发送窗口进行速率的控制，发送窗口一般等于接收窗口，而有了拥塞控制后，发送窗口会取拥塞窗口和接收窗口的最小值</u></p><h3 id="慢启动" tabindex="-1">慢启动 <a class="header-anchor" href="#慢启动" aria-label="Permalink to &quot;慢启动&quot;">​</a></h3><p>在TCP连接建立时，发送方会将拥塞窗口的大小设置为一个较小的值，通常为2个最大分段大小（MSS）。发送方将拥塞窗口的大小逐渐增加，每发送一个数据段就将窗口大小加1，这样可以使得发送方逐渐探测网络的可用带宽。但不可能一直这样增长下去，当拥塞窗口大小达到一个阈值时，发送方将进入拥塞避免阶段，此时拥塞窗口的增加速率将变慢</p><p>假如拥塞窗口刚开始为1，当接受到1个ACK后，窗口大小加1可以同时发送2个SYN，然后接受到2个ACK后变成窗口大小变为4；接着发送4个SYN收到后大小变成8；就这样反复增加直到达到最大阈值，慢启动算法就是以指数的形式增加，增加速度比较快</p><h3 id="拥塞避免" tabindex="-1">拥塞避免 <a class="header-anchor" href="#拥塞避免" aria-label="Permalink to &quot;拥塞避免&quot;">​</a></h3><p>当达到慢启动的阈值时就会进入拥塞避免算法，以防止指数级的发送造成网络堵塞问题，拥塞避免算法当收到1个ACK时，拥塞窗口增加<code>1/n</code>个大小，这样窗口的增长速率会越来越小</p><p>除了慢启动、拥塞避免算法外，还有快速恢复算法快速来恢复发送速率，这里不再展开了</p><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h2><p>本文从TCP的首部、建立断开、传输过程、重传机制、拥塞控制等多方面讲述了TCP协议的工作方式和细节，而TCP远不止这么简单内容，作为非网络工程师对于更深的概念了解下即可，掌握这些通常足够了</p><h2 id="参考文献" tabindex="-1">参考文献 <a class="header-anchor" href="#参考文献" aria-label="Permalink to &quot;参考文献&quot;">​</a></h2><ul><li><a href="https://book.douban.com/subject/30280001/" target="_blank" rel="noreferrer">计算机网络(自定向下方法第7版)</a></li><li><a href="https://book.douban.com/subject/26825411/" target="_blank" rel="noreferrer">TCP/IP详解 卷1：协议（原书第2版）</a></li></ul>`,104);function i(C,d,u,y,h,b){const n=a("Reward"),e=a("Gitalk");return c(),p("div",null,[t,s(n),s(e)])}const F=l(r,[["render",i]]);export{T as __pageData,F as default};
